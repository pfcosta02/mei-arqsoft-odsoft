import org.jenkinsPipeline.Constants

// Scripted Pipeline for AuthNUsers Command Service
properties([
    parameters([
        choice(
            name: "RolloutStrategy",
            choices: ['Blue/Green', 'Canary', 'Rolling'],
            description: 'Choose a Rollout Strategy.'
        )
    ])
])

node {
    def MAVEN_DIR = tool(name: 'Maven 3.9.11', type: 'maven')
    def PROJECT_VERSION = ''
    def IMAGE_NAME = 'lms-readers-command'
    def RESULT_STR = ''
    def CURRENT_COLOR // Cor atual do deployment (blue, green ou none)
    def NEW_COLOR // Nova cor para o deployment
    def NAMESPACE = 'dev' // Kubernetes namespace
    def DOCKER_IMAGE = ''
    
    try 
    {
        stage('Checkout') 
        {
            echo 'Checking out source code...'
            checkout scm
            
            // Clean untracked files and directories from Git workspace
            echo 'Cleaning untracked files from Git...'
            if (isUnix()) 
            {
                sh 'git clean -fdx'
            } 
            else 
            {
                bat 'git clean -fdx'
            }
        }
        
        stage('Set Maven Path') 
        {
            if (isUnix()) 
            {
                env.PATH = "${MAVEN_DIR}/bin:${env.PATH}"
            } 
            else 
            {
                env.PATH = "${MAVEN_DIR}\\bin;${env.PATH}"
            }
            echo "Maven added to PATH: ${env.PATH}"
        }
        
        dir(IMAGE_NAME) 
        {   
            stage('Clean + Build') 
            {
                CleanAndBuild();
            }

            stage('Unit Tests') 
            {
                UnitTests();
            }

            stage('Integration Tests') 
            {
                IntegrationTests();
            }

            stage('Consumer Contract Tests (Pact)') 
            {
                // false significa que é um producer
                ConsumerContractTests(false);
            }
            
            stage('SonarQube Static Code Analysis') 
            {

                def sonarServer = Constants.ENVIRONMENT_2_SONARQUBE_SERVER[params.Environment]
                echo "Running SonarQube analysis using server: ${sonarServer}"

                // withSonarQubeEnv(sonarServer) {
                //     if (isUnix()) {
                //         sh "mvn verify -X sonar:sonar"
                //     } else {
                //         bat "mvn verify -X sonar:sonar"
                //     }
                // }
            }

            stage('SonarQube Quality Gate') 
            {
                // timeout(time: 5, unit: 'MINUTES') {
                //     def qualityGateResult = waitForQualityGate(abortPipeline: true)
                //     if (qualityGateResult.status == 'OK') {
                //         echo 'Quality gate passed. Proceeding with the pipeline.'
                //     } else {
                //         error "Quality gate failed: ${qualityGateResult.status}"
                //     }
                // }
            }
            
            // stage('JaCoCo') {
            //     jacoco execPattern: '**/target/jacoco.exec',
            //            classPattern: '**/target/classes',
            //            sourcePattern: '**/src/main/java',
            //            inclusionPattern: '**/*.class'
            // }

            stage('Package') 
            {
                PROJECT_VERSION = Package();
            }

            stage('Build Docker Image') 
            {
                // Resultado deve ser algo como 'forjemzer/lms-readers-command:1.0'
                RESULT_STR = "${IMAGE_NAME}:${PROJECT_VERSION}"
                DOCKER_IMAGE = "${Constants.DOCKER_REGISTRY}/${RESULT_STR}"
                BuildDockerImage(RESULT_STR);
            }

            stage('Push Docker Image') 
            {
                PushDockerImage(RESULT_STR);
            }

//             stage('Deploy')
//             {
//                 /*
//                 * Garante infraestrutura base do Kubernetes
//                 * (namespace, service, RabbitMQ) - comum a todas as estratégias
//                 */
//                 EnsureK8sStructure(IMAGE_NAME, NAMESPACE)
//
//                 if (params.RolloutStrategy == 'Blue/Green')
//                 {
//                     echo 'Deploying the application using Blue/Green strategy...'
//
//                     /* Conectar ao Kubernetes e obter a cor do pod atual */
//                     CURRENT_COLOR = GetCurrentDeploymentColor(IMAGE_NAME, NAMESPACE)
//                     echo "Current active deployment color: ${CURRENT_COLOR}"
//
//                     /* Determinar a nova cor (oposta à atual) */
//                     NEW_COLOR = (CURRENT_COLOR == 'blue') ? 'green' : 'blue'
//                     echo "New deployment color will be: ${NEW_COLOR}"
//
//                     /*
//                     * ABORDAGEM ESCOLHIDA: Dynamic Image Update via kubectl set image
//                     *
//                     * JUSTIFICATIVA:
//                     * Esta abordagem utiliza um deployment fixo para cada cor (blue e green),
//                     * mas atualiza dinamicamente a imagem através do comando kubectl set image.
//                     *
//                     * VANTAGENS:
//                     * 1. Separação clara entre blue/green através de deployments distintos
//                     * 2. Versionamento automático via PROJECT_VERSION do Maven
//                     * 3. Rollback facilitado através de kubectl rollout undo
//                     * 4. Histórico de versões mantido pelo Kubernetes (revision history)
//                     * 5. Não requer alteração de manifestos YAML a cada deploy
//                     * 6. Suporta rolling updates nativos do Kubernetes
//                     *
//                     * ALTERNATIVAS CONSIDERADAS E REJEITADAS:
//                     *
//                     * A) Deployment fixo com versão 1.0 (mencionado pelo professor):
//                     *    - Problema: Não permite versionamento adequado
//                     *    - Problema: Dificulta rastreabilidade de versões
//                     *    - Problema: Complica rollbacks para versões específicas
//                     *
//                     * B) Recriar deployment completo a cada vez:
//                     *    - Problema: Perde histórico de revisões do Kubernetes
//                     *    - Problema: Mais complexo (requer templates ou geração de YAML)
//                     *    - Problema: Maior janela de downtime
//                     *
//                     * C) Helm Charts com values dinâmicos:
//                     *    - Vantagem: Gestão mais sofisticada de configurações
//                     *    - Desvantagem: Adiciona complexidade desnecessária para este caso
//                     *    - Desvantagem: Requer instalação e configuração do Helm
//                     *
//                     * D) Kustomize overlays:
//                     *    - Vantagem: Declarativo e versionável
//                     *    - Desvantagem: Requer estrutura de diretórios mais complexa
//                     *    - Desvantagem: Overhead para casos simples de blue/green
//                     *
//                     * FLUXO DA ABORDAGEM ESCOLHIDA:
//                     * 1. Identifica cor atual através do Service selector
//                     * 2. Atualiza deployment da nova cor com a nova versão da imagem
//                     * 3. Aguarda deployment estar ready (rollout status)
//                     * 4. Executa testes de smoke
//                     * 5. Atualiza Service para apontar para a nova cor
//                     * 6. Remove deployment da cor antiga após validação
//                     */
//
//                     /* Atualizar o deployment da nova cor com a nova imagem */
//                     DeployNewColor(IMAGE_NAME, NEW_COLOR, DOCKER_IMAGE, NAMESPACE)
//
//                     /* Aguardar que o deployment esteja pronto */
//                     WaitForDeploymentReady(IMAGE_NAME, NEW_COLOR, NAMESPACE)
//                 }
//                 else
//                 {
//                     echo "Deployment strategy ${params.RolloutStrategy} is not implemented yet."
//                 }
//             }
//
//             stage('Test Instance')
//             {
//                 if (params.RolloutStrategy == 'Blue/Green')
//                 {
//                     echo "Running tests on ${NEW_COLOR} instance..."
//
//                     /*
//                     * Testes de validação ANTES do switch de tráfego
//                     *
//                     * COMPORTAMENTO:
//                     * - Testa a nova instância isolada (sem tráfego de produção)
//                     * - Se PASSAR: pipeline continua para SwitchTraffic
//                     * - Se FALHAR: pipeline PARA aqui, deployment falhado é removido
//                     *
//                     * VANTAGEM: Versão ruim NUNCA recebe tráfego de produção
//                     *
//                     * Inclui: health checks, readiness checks, smoke tests
//                     */
//                     //ValidateDeploymentWithRollback(IMAGE_NAME, NEW_COLOR, CURRENT_COLOR, NAMESPACE)
//
//                     echo "All tests passed on ${NEW_COLOR} instance - SAFE TO SWITCH"
//                 }
//                 else
//                 {
//                     echo "Testing strategy for ${params.RolloutStrategy} is not implemented yet."
//                 }
//             }
//
//             stage('Manual Approval Required')
//             {
//                 if (params.RolloutStrategy == 'Blue/Green')
//                 {
//                     /*
//                     * Aprovação manual antes do deployment em produção
//                     *
//                     * NOTIFICAÇÃO:
//                     * - O Jenkins exibe notificação no UI
//                     * - Console log mostra mensagem clara
//                     * - Para Jenkins com email configurado, pode usar emailext plugin
//                     *
//                     * APROVAÇÃO:
//                     * - Pipeline PAUSA até alguém aprovar ou rejeitar
//                     * - Timeout de 30 minutos (customizável)
//                     * - Se timeout expirar, deployment é abortado
//                     *
//                     * CONTROLE:
//                     * - Apenas utilizadores com permissões podem aprovar
//                     * - Submitter pode ser especificado (ex: 'admin,lead-dev')
//                     */
//                     echo""" ==========================================
//                             DEPLOYMENT APPROVAL REQUIRED
//                             ==========================================
//                             Service: ${IMAGE_NAME}
//                             New Version: ${PROJECT_VERSION}
//                             Target Color: ${NEW_COLOR}
//                             Current Color: ${CURRENT_COLOR}
//                             Namespace: ${NAMESPACE}
//                             Docker Image: ${DOCKER_IMAGE}
//                             ==========================================
//                             Tests have PASSED. Waiting for manual approval to switch traffic...
//                             ==========================================
//                         """
//
//                     try
//                     {
//                         // Envia email de notificação
//                         emailext(
//                             subject: "Deployment Approval Required: ${IMAGE_NAME}:${PROJECT_VERSION}",
//                             body: """
//                                 Deployment waiting for approval:
//                                 - Service: ${IMAGE_NAME}
//                                 - Version: ${PROJECT_VERSION}
//                                 - Target: ${NEW_COLOR}
//
//                                 Approve at: ${BUILD_URL}input
//                             """,
//                             to: 'test@localhost'
//                         )
//
//                         timeout(time: 30, unit: 'MINUTES')
//                         {
//                             input message: "Deploy ${IMAGE_NAME}:${PROJECT_VERSION} to production?",
//                                   ok: 'Deploy',
//                                   submitter: 'admin,authenticated' // Customize with your Jenkins user roles
//                         }
//                         echo "Deployment APPROVED by user. Proceeding with traffic switch..."
//                     }
//                     catch (err)
//                     {
//                         echo "Deployment REJECTED or TIMEOUT. Aborting deployment..."
//                         echo "Cleaning up ${NEW_COLOR} deployment that was never switched to production..."
//
//                         /*
//                         * CLEANUP quando aprovação é rejeitada/timeout
//                         *
//                         * COMPORTAMENTO:
//                         * - Remove deployment da nova cor que foi criado mas nunca recebeu tráfego
//                         * - Tráfego continua na cor antiga (CURRENT_COLOR)
//                         * - Sistema fica no estado anterior ao deployment
//                         *
//                         * VANTAGEM: Não deixa lixo (deployments órfãos) no cluster
//                         */
//                         RollbackBlueGreen(IMAGE_NAME, NEW_COLOR, CURRENT_COLOR, NAMESPACE)
//
//                         currentBuild.result = 'ABORTED'
//                         throw new Exception("Manual approval denied or timed out")
//                     }
//                 }
//                 else
//                 {
//                     echo "Manual approval for ${params.RolloutStrategy} is not implemented yet."
//                 }
//             }
//
//             stage('Switch Traffic to New Instance')
//             {
//                 if (params.RolloutStrategy == 'Blue/Green')
//                 {
//                     echo "Switching traffic from ${CURRENT_COLOR} to ${NEW_COLOR}..."
//
//                     /*
//                     * Atualiza o Service para apontar para a nova cor
//                     *
//                     * NOTA: Este stage só é executado se o stage anterior (testes) passar
//                     *       Isto garante que versão ruim nunca recebe tráfego
//                     *
//                     * O switch é ATÔMICO - demonstra ZERO DOWNTIME
//                     */
//                     SwitchTraffic(IMAGE_NAME, NEW_COLOR, NAMESPACE)
//
//                     echo "Traffic successfully switched to ${NEW_COLOR}"
//                 }
//                 else
//                 {
//                     echo "Traffic switching strategy for ${params.RolloutStrategy} is not implemented yet."
//                 }
//             }
//
//             stage('Undeploy old service')
//             {
//                 if (params.RolloutStrategy == 'Blue/Green')
//                 {
//                     echo "Removing old ${CURRENT_COLOR} deployment..."
//
//                     /*
//                     * Apenas remove o deployment antigo se houver um
//                     * Mantém o Service (que agora aponta para a nova cor)
//                     * Permite rollback manual se necessário antes desta etapa
//                     */
//                     if (CURRENT_COLOR != 'none')
//                     {
//                         UndeployOldColor(IMAGE_NAME, CURRENT_COLOR, NAMESPACE)
//                         echo "${CURRENT_COLOR} deployment removed successfully"
//                     }
//                     else
//                     {
//                         echo "No old deployment to remove (first deployment)"
//                     }
//                 }
//                 else
//                 {
//                     echo "Undeployment strategy for ${params.RolloutStrategy} is not implemented yet."
//                 }
//             }
//         }
//
//         // Success actions
//         echo 'Pipeline completed successfully.'
//         if (isUnix()) {
//             archiveArtifacts artifacts: "**/target/pit-reports/index.html,**/target/pacts/*.json", allowEmptyArchive: true
//             junit skipPublishingChecks: true, testResults: '**/target/surefire-reports/*.xml'
//         } else {
//             archiveArtifacts artifacts: "**\\target\\pit-reports\\index.html,**\\target\\pacts\\*.json", allowEmptyArchive: true
//             junit skipPublishingChecks: true, testResults: '**\\target\\surefire-reports\\*.xml'
//         }
        
    } catch (Exception e) {
        echo "ERROR FOUND! ${e.getMessage()}"
        currentBuild.result = 'FAILURE'
        throw e
    } finally {
        echo 'Performing cleanup...'
        /* Cleanup workspace with patterns */
        cleanWs(
            patterns: [
                [pattern: '**/*', type: 'INCLUDE']
            ],
            deleteDirs: true,
            notFailBuild: true
        )
    }
}
