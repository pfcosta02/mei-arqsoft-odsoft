import org.jenkinsPipeline.Constants

// Scripted Pipeline for AuthNUsers Command Service
properties([
    parameters([
        choice(
            name: 'Environment', 
            choices: ['local', 'docker'],
            description: 'Choose an Environment.'
        ),
        choice(
            name: "RolloutStrategy",
            choices: ['Blue/Green', 'Canary', 'Rolling'],
            description: 'Choose a Rollout Strategy.'
        )
    ])
])

node {
    def MAVEN_DIR = tool(name: 'Maven 3.9.11', type: 'maven')
    def PROJECT_VERSION = ''
    def IMAGE_NAME = 'lms-readers-query'
    def RESULT_STR = ''
    def CURRENT_COLOR // Cor atual do deployment (blue, green ou none)
    def NEW_COLOR // Nova cor para o deployment
    def NAMESPACE = 'dev' // Kubernetes namespace
    def DOCKER_IMAGE = ''
    
    try 
    {
        stage('Checkout') 
        {
            echo 'Checking out source code...'
            checkout scm
            
            // Clean untracked files and directories from Git workspace
            echo 'Cleaning untracked files from Git...'
            if (isUnix()) 
            {
                sh 'git clean -fdx'
            } 
            else 
            {
                bat 'git clean -fdx'
            }
        }
        
        stage('Set Maven Path') 
        {
            if (isUnix()) 
            {
                env.PATH = "${MAVEN_DIR}/bin:${env.PATH}"
            } 
            else 
            {
                env.PATH = "${MAVEN_DIR}\\bin;${env.PATH}"
            }
            echo "Maven added to PATH: ${env.PATH}"
        }
        
        dir(IMAGE_NAME) 
        {   
            stage('Clean + Build') 
            {
                CleanAndBuild();
            }

            stage('Unit Tests') 
            {
                UnitTests();
            }

            stage('Integration Tests') 
            {
                IntegrationTests();
            }

            stage('Consumer Contract Tests (Pact)') 
            {
                // false significa que é um producer
                ConsumerContractTests(false);
            }
            
            stage('SonarQube Static Code Analysis') 
            {

                def sonarServer = Constants.ENVIRONMENT_2_SONARQUBE_SERVER[params.Environment]
                echo "Running SonarQube analysis using server: ${sonarServer}"

                // withSonarQubeEnv(sonarServer) {
                //     if (isUnix()) {
                //         sh "mvn verify -X sonar:sonar"
                //     } else {
                //         bat "mvn verify -X sonar:sonar"
                //     }
                // }
            }

            stage('SonarQube Quality Gate') 
            {
                // timeout(time: 5, unit: 'MINUTES') {
                //     def qualityGateResult = waitForQualityGate(abortPipeline: true)
                //     if (qualityGateResult.status == 'OK') {
                //         echo 'Quality gate passed. Proceeding with the pipeline.'
                //     } else {
                //         error "Quality gate failed: ${qualityGateResult.status}"
                //     }
                // }
            }
            
            // stage('JaCoCo') {
            //     jacoco execPattern: '**/target/jacoco.exec',
            //            classPattern: '**/target/classes',
            //            sourcePattern: '**/src/main/java',
            //            inclusionPattern: '**/*.class'
            // }

            stage('Package') 
            {
                PROJECT_VERSION = Package();
            }

            stage('Build Docker Image') 
            {
                // Resultado deve ser algo como 'forjemzer/lms-readers-command:1.0'
                RESULT_STR = "${IMAGE_NAME}:${PROJECT_VERSION}"
                DOCKER_IMAGE = "${Constants.DOCKER_REGISTRY}/${RESULT_STR}"
                BuildDockerImage(RESULT_STR);
            }

            stage('Push Docker Image') 
            {
                PushDockerImage(RESULT_STR);
            }

            stage('Deploy') 
            {
                /*
                * Garante infraestrutura base do Kubernetes
                * (namespace, service, RabbitMQ) - comum a todas as estratégias
                */
                EnsureK8sStructure(IMAGE_NAME, NAMESPACE)

                if (params.RolloutStrategy == 'Blue/Green') 
                {
                    echo 'Deploying the application using Blue/Green strategy...'
                    
                    /* Conectar ao Kubernetes e obter a cor do pod atual */
                    CURRENT_COLOR = GetCurrentDeploymentColor(IMAGE_NAME, NAMESPACE)
                    echo "Current active deployment color: ${CURRENT_COLOR}"
                    
                    /* Determinar a nova cor (oposta à atual) */
                    NEW_COLOR = (CURRENT_COLOR == 'blue') ? 'green' : 'blue'
                    echo "New deployment color will be: ${NEW_COLOR}"
                    
                    /* 
                    * ABORDAGEM ESCOLHIDA: Dynamic Image Update via kubectl set image
                    * 
                    * JUSTIFICATIVA:
                    * Esta abordagem utiliza um deployment fixo para cada cor (blue e green),
                    * mas atualiza dinamicamente a imagem através do comando kubectl set image.
                    * 
                    * VANTAGENS:
                    * 1. Separação clara entre blue/green através de deployments distintos
                    * 2. Versionamento automático via PROJECT_VERSION do Maven
                    * 3. Rollback facilitado através de kubectl rollout undo
                    * 4. Histórico de versões mantido pelo Kubernetes (revision history)
                    * 5. Não requer alteração de manifestos YAML a cada deploy
                    * 6. Suporta rolling updates nativos do Kubernetes
                    * 
                    * ALTERNATIVAS CONSIDERADAS E REJEITADAS:
                    * 
                    * A) Deployment fixo com versão 1.0 (mencionado pelo professor):
                    *    - Problema: Não permite versionamento adequado
                    *    - Problema: Dificulta rastreabilidade de versões
                    *    - Problema: Complica rollbacks para versões específicas
                    * 
                    * B) Recriar deployment completo a cada vez:
                    *    - Problema: Perde histórico de revisões do Kubernetes
                    *    - Problema: Mais complexo (requer templates ou geração de YAML)
                    *    - Problema: Maior janela de downtime
                    * 
                    * C) Helm Charts com values dinâmicos:
                    *    - Vantagem: Gestão mais sofisticada de configurações
                    *    - Desvantagem: Adiciona complexidade desnecessária para este caso
                    *    - Desvantagem: Requer instalação e configuração do Helm
                    * 
                    * D) Kustomize overlays:
                    *    - Vantagem: Declarativo e versionável
                    *    - Desvantagem: Requer estrutura de diretórios mais complexa
                    *    - Desvantagem: Overhead para casos simples de blue/green
                    * 
                    * FLUXO DA ABORDAGEM ESCOLHIDA:
                    * 1. Identifica cor atual através do Service selector
                    * 2. Atualiza deployment da nova cor com a nova versão da imagem
                    * 3. Aguarda deployment estar ready (rollout status)
                    * 4. Executa testes de smoke
                    * 5. Atualiza Service para apontar para a nova cor
                    * 6. Remove deployment da cor antiga após validação
                    */
                    
                    /* Atualizar o deployment da nova cor com a nova imagem */
                    DeployNewColor(IMAGE_NAME, NEW_COLOR, DOCKER_IMAGE, NAMESPACE)
                    
                    /* Aguardar que o deployment esteja pronto */
                    WaitForDeploymentReady(IMAGE_NAME, NEW_COLOR, NAMESPACE)
                } 
                else 
                {
                    echo "Deployment strategy ${params.RolloutStrategy} is not implemented yet."
                }
            }

            stage('Test Instance') 
            {
                if (params.RolloutStrategy == 'Blue/Green') 
                {
                    echo "Running tests on ${NEW_COLOR} instance..."
                    
                    /*
                    * Testes de validação ANTES do switch de tráfego
                    * 
                    * COMPORTAMENTO:
                    * - Testa a nova instância isolada (sem tráfego de produção)
                    * - Se PASSAR: pipeline continua para SwitchTraffic
                    * - Se FALHAR: pipeline PARA aqui, deployment falhado é removido
                    * 
                    * VANTAGEM: Versão ruim NUNCA recebe tráfego de produção
                    * 
                    * Inclui: health checks, readiness checks, smoke tests
                    */
                    //ValidateDeploymentWithRollback(IMAGE_NAME, NEW_COLOR, CURRENT_COLOR, NAMESPACE)
                    
                    echo "All tests passed on ${NEW_COLOR} instance - SAFE TO SWITCH"
                }
                else 
                {
                    echo "Testing strategy for ${params.RolloutStrategy} is not implemented yet."
                }
            }
            
            stage('Switch Traffic to New Instance')
            {
                if (params.RolloutStrategy == 'Blue/Green') 
                {
                    echo "Switching traffic from ${CURRENT_COLOR} to ${NEW_COLOR}..."
                
                    /*
                    * Atualiza o Service para apontar para a nova cor
                    * 
                    * NOTA: Este stage só é executado se o stage anterior (testes) passar
                    *       Isto garante que versão ruim nunca recebe tráfego
                    * 
                    * O switch é ATÔMICO - demonstra ZERO DOWNTIME
                    */
                    SwitchTraffic(IMAGE_NAME, NEW_COLOR, NAMESPACE)
                    
                    echo "Traffic successfully switched to ${NEW_COLOR}"
                } 
                else 
                {
                    echo "Traffic switching strategy for ${params.RolloutStrategy} is not implemented yet."
                }
            }

            stage('Undeploy old service') 
            {
                if (params.RolloutStrategy == 'Blue/Green') 
                {
                    echo "Removing old ${CURRENT_COLOR} deployment..."
                    
                    /*
                    * Apenas remove o deployment antigo se houver um
                    * Mantém o Service (que agora aponta para a nova cor)
                    * Permite rollback manual se necessário antes desta etapa
                    */
                    if (CURRENT_COLOR != 'none') 
                    {
                        UndeployOldColor(IMAGE_NAME, CURRENT_COLOR, NAMESPACE)
                        echo "${CURRENT_COLOR} deployment removed successfully"
                    } 
                    else 
                    {
                        echo "No old deployment to remove (first deployment)"
                    }
                }
                else
                {
                    echo "Undeployment strategy for ${params.RolloutStrategy} is not implemented yet."
                }
            }
        }

        // Success actions
        echo 'Pipeline completed successfully.'
        if (isUnix()) {
            archiveArtifacts artifacts: "**/target/pit-reports/index.html,**/target/pacts/*.json", allowEmptyArchive: true
            junit skipPublishingChecks: true, testResults: '**/target/surefire-reports/*.xml'
        } else {
            archiveArtifacts artifacts: "**\\target\\pit-reports\\index.html,**\\target\\pacts\\*.json", allowEmptyArchive: true
            junit skipPublishingChecks: true, testResults: '**\\target\\surefire-reports\\*.xml'
        }
        
    } catch (Exception e) {
        echo "ERROR FOUND! ${e.getMessage()}"
        currentBuild.result = 'FAILURE'
        throw e
    } finally {
        echo 'Performing cleanup...'
        /* Cleanup workspace with patterns */
        cleanWs(
            patterns: [
                [pattern: '**/*', type: 'INCLUDE']
            ],
            deleteDirs: true,
            notFailBuild: true
        )
    }
}
